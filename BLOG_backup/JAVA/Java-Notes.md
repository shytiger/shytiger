---
title: Java-Notes
date: 2020-08-28 09:52:45
tags:LearnNotes
---

# 注解_反射_字节码_类加载机制  
## 注解  
- Annotation的作用
  - 对程序做索命
  - 可以被其他程序（比如：编译器等）读取
- Annotation格式
- 内置注解：
  - @Override
  - @Deprecated
  - @SupperessWarnings
- 元注解 对注解进行解释
  - @Target
  - @Retention
    - 表示
- 练习  

## 类加载机制
- 加载
  - 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的`java.lang.Class`对象，作为方法区类数据访问入口。
- 链接 将java类的二进制代码合并到JVM的运行状态之中的过程
  - 验证：
    - 确保加载的类信息符合JVM规范，没有安全方面的问题
  - 准备：
    - 正式为类变量(static变量)分配内存并设置类变量初始化的阶段，这些内存将在方法区中进行分配
  - 解析：虚拟机常量池内的**符号引用**替换为**直接引用**的过程
    - 常量 类名 方法名 参数名 等 作为常量存在  >> （符号引用）放置在常量池>> 不能直接用 >> 直接引用 
- 初始化
  - 初始化阶段是执行类构造器<clinit>()方法的过程，类构造器<clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（switch块）中的语句合并产生的
  - 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先出发其父类的初始化
  - 虚拟机会保证一个类的<clinit>()方法子啊多线程环境中被正确加锁和同步
  - 当访问一个java类的静态区域时，只有真正声明这个区域的类才会被初始化
- 类的主动引用与被动引用
  - 主动引用（一定会发生类的初始化）
    - new一个对象
    - 调用类的静态成员（除了final常量）和静态方法
    - 使用反射调用
    - 虚拟机启动时，一定会调用main方法所在的类
    - 当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类
  - 被动引用  
    - 当访问一个静态域时，只有真正声明这个域的类才会被初始化
      - 如子类引用父类的静态变量，不会导致子类初始化
    - 通过数组定义类引用，不会触发此类的初始化
    - 引用常量不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中）

- 类加载器的层次结构
  - 引导类加载器（c写的）
  - 拓展类加载器
  - 应用程序类加载器
  - 自定义类加载器  
- 类加载器的代理模式
  - 代理模式  
    - 交给其他加载器来加载指定的类
  - 双亲委托机制
    - 安全：优先加载系统的类
    - 双亲委托时代理模式的一种
      - tomcat服务器类加载器也使用代理模式，所不同的时他首先尝试区加载某个类，如果找不到在代理给父类加载器，这与一般类加载器的顺序相反  
- 自定义类加载器一般流程
  - 继承java.lang.ClassLoader
  - 
- 被两个类加载器加载的同一个类，JVM不认为是相同的类
- 线程上下文类加载器
- OSGI
  - 谁定义的类，谁来加载

# 设计模式
- 创建型模式
  - 单例模式，工厂模式等
- 单例模式
  - 核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。
  - 常用的应用场景：
    - windows的Task Manager
    - windows的Recycle Bin

- 单例模式
  - 饿汉式
    - 特点：线程安全，调用效率高
    - 构造器私有 
    - 类初始化时立即加载
  - 懒汉式
    - 延迟加载
    - 特点：资源效率高，调用效率低（需要加同步）
    - 列初始化时，不初始化这个对象（延迟加载）
  - 静态内部类  
  - 枚举方式
    - 没有延时加载

- 工厂模式
  - 实现了创建者和调用者的分离
  - 详细分类
    - 简单工厂模式
    - 工厂方法模式
      - 解决简单工厂不完全满足 OCP原则
    - 抽象工厂模式
      - 用来生产不同产品族的全部产品（对于新增加的产品，无能为力，支持增加产品族）。
      - 
  - 面向对象设计的基本原则
    - OCP（开闭原则，Open-Closed Principle） 对拓展开放，对修改关闭
    - DIP(依赖倒转原则，Dependence Inversion Principle) 针对接口编程，不要针对是实现编程 （实现类与类的解耦）
    - LoD(迪米特法则，Law of Demeter) 只与你直接的朋友通信，而避免和陌生人通信
  
- 建造者模式
  - 构建零件
  - 本质
    - 构建和装配的解耦
- 